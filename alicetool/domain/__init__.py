'''
> Слой модели
Отвечает за представление понятий прикладной предметной области, 
рабочие состояния, деловые регламенты. Именно здесь 
контроллируется и используется текущее состояние прикладной модели, 
пусть даже технические подробности манипуляций данными делегируется 
инфраструктуре.
Этот уровень является главной алгоритмической частью программы.

Основные шаблоны, используемые в доменной области:
  Ассоциации.
Для всякой прослеживаемой в модели ассоциации 
должен существовать механизм в программе, обладающий теми-же свойствами.

  Сущности, указуемые объекты (Entity)
Логически целостные объекты, определяемые совокупностью индивидуальных черт. 
На протяжении их цикла существования у них может радикально меняться и форма, 
и содержание, но непрерывность этого существования обязана поддерживаться. 
Они должны идентифицироваться таким образом, чтобы их можно было 
однозначно отследить.
Основная функция сущности - поддерживать непрерывность своего существования 
таким образом, чтобы её поведение было понятным и предсказуемым.
Кроме индивидуальности и непрерывности существования для сущностей 
часто характерно то, что они выполняют свои функции, 
координируя операции объектов которые им принадлежат.

  Объекты значения (Value-object)
У многих объектов в принципе нет индивидуального существования. 
Они описываю характеристики того или иного предмета.
Если элемент модели полностью определяется своими атрибутами, 
то его следует сделать объектом-значением. 
Сделайте так, чтобы он отражал смысл заложенных в него атрибутов 
и придайте ему соответствующую функциональность. 
Считайте такой объект неизменяемым. Не давайте ему индивидуальности, 
вообще избегайте любых сложностей, 
неизбежных при программном управлении сущностями (Entity).
Аттрибуты, образующие в совокупности объект-значение, 
должны быть концептуальным целым.
Объект значение может представлять собой совокупность других объектов 
и даже ссылаться на сущности.
особые случаи: когда разрешать изменяемость объекта-значения:
- частые изменения значения объекта
- затратность создания и уничтожения
- опасность замены вместо модификации при группировании объектов
- незначительное совместное использование или же полный отказ от него 
с целью улучшения группирования объектов или из каких-то других 
технических соображений.

  Службы (Service)
В предметной области бывают такие операции которым нельзя найти 
естественное место в объекте типа сущности или значения. 
Они по своей сути являются не предметами, а видами деятельности. 
Но поскольку в основе нашей парадигмы моделирования лежит объектный подход, 
мы попробуем превратить их в объекты.
Хорошая служба обладает тремя свойствами:
- выполняемая ею операция соответствует понятию модели, 
не являющемуся естественной частью объекта-сущности или объекта-значения.
- интерфейс службы определён через другие элементы модели предметной области
- операция не имеет собственного состояния

  Модули (Packages)
На уровне предметной области модули должны соответствовать 
смысловым частям модели, выражая суть и структуру модели в крупном масштабе.
Давайте модулям такие имена, которые войдут в единый язык. 
Как сами модули, так и их имена должны отражать 
знание и понимание предметной области.
Если нет реальной необходимости распределять код между разными серверами, 
храните весь код, реализующий один концептуальный объект, 
в одном модуле, а то и классе.
Используйте разбиение на пакеты только для того, чтобы отделить уровень 
предметной области от остального кода. 
Оставляйте побольше свободы разработчикам модели предметной области, 
чтобы они могли объединить её объекты в пакеты таким образом, 
какой лучше всего подходит для выражения модели 
и проектных архитектурных решений.

  Агрегат (Aggregate)
При внесении изменений в объекты модели, 
обладающей сложной системой ассоциаций, 
трудно гарантировать согласованность этих изменений. 
Необходимо соблюдать инварианты, 
относящиеся к тесно связанным группам объектов, а не отдельным объектам.
Но если применить слишком осторожные схемы блокирования, 
то параллельные пользователи станут невольно мешать друг другу, 
и это сделает всю систему неработоспособной.
Чтобы реализовать концепцию агрегата в виде практической 
программной конструкции, необходимо иметь набор правил, 
выполняющихся для любой транзакции:
- Корневой объект-сущность имеет глобальную идентичность 
и несёт полную ответственность за проверку инвариантов.
- некорневые объекты сущности имеют локальную идентичность 
(они уникальны только в границах агрегата)
- Нигде за пределами агрегата не может храниться ссылка 
на что-либо внутри него, кроме его корневого объекта. 
(Корневой объект-сущность может передавать ссылки на внутренние 
объекты сущности другим объектам. Но эти другие объекты 
могут использовать их только временно, 
и не имеют права хранить их или как-то фиксировать. 
Корневой объект может передать копию объекта-значения другому объекту, 
и что с ней потом случится - не играет роли, 
поскольку это не более чем значение, 
и оно не имеет никаких связей с агрегатом.)
- Как следствие из предыдущего правила, только корневые объекты агрегатов 
можно непосредственно получить по запросам из базы данных. 
Все остальные объекты разрешается извлекать только по цепочке связей.
- Объекты внутри агрегата могут хранить ссылки на корневые объекты 
других агрегатов
- Операция удаления должна одновременно ликвидировать всё, 
что находится в границах агрегата. (При наличии сборки мусора это просто. 
Поскольку внешних ссылок ни на что кроме корневого объекта не существует, 
достаточно удалить корневой объект, а остальное будет подчищено при сборке.)
- Как только вносится изменение в любой объект внутри границ агрегата, 
следует сразу удовлетворить все инварианты этого агрегата.
Фабрики и хранилища оперируют агрегатами, 
инкапсулируя в себе некоторые сложные преобразования, 
выполняемые в жизненном цикле объектов.

  Фабрика (Factory)
Если создание объекта или целого агрегата представляет большую сложность 
или открывает постороннему глазу слишком много внутренней структуры, 
то нужную инкапсуляцию обеспечивают фабрики.
Передайте обязанности по созданию экземпляров сложных объектов и агрегатов 
отдельному объекту, который сам по себе может не выполнять 
никаких функций в модели предметной области, но, тем не менее 
является элементом её архитектуры. 
Обеспечьте интерфейс, который бы инкапсулировал все 
сложные операции сборки объекта и не требовал от клиента 
ссылаться на конкретные классы создаваемого объекта. 
Создайте агрегаты как единое целое, контролируя выполнение инвариантов.
Любая хорошая фабрика должна отвечать двум фундаментальным требованиям:
1. каждый метод создания объекта должен быть един и неделим; 
он должен гарантировать соблюдение всех инвариантов 
создаваемого объекта или агрегата. 
Фабрика должна уметь создавать только объект целиком в корректном состоянии.
Для объекта-сущности это означает создание сразу целого агрегата 
с соблюдением всех инвариантов;
Только необязательные второстепенные элементы разрешается добавить позже. 
Для неизменяемого объекта-значения это означает, 
что все атрибуты инициализируется окончательными корректными значениями. 
Если интерфейс позволяет клиенту запросить создание некорректного объекта, 
то должна инициироваться исключительная ситуация или запуститься какой-то 
другой механизм, не позволяющий возвратить некорректное значение. 
(Будьте последовательны и примите единый стандарт программирования 
для работы с ошибками создания объектов в фабриках)
2. Абстрагировать фабрику следует к желаемому типу, а не к конкретному классу.
Фабрика должна быть связана со своими аргументами. 
Если неосторожно выбрать набор входных параметров, 
можно создать целую паутину взаимосвязей. 
На степень зависимости влияют операции, которые выполняются над аргументом. 
Если он просто вставляется в создаваемый объект, эта связь невелика. 
Но если при конструировании объекта из аргумента берутся фрагменты, 
зависимость становится сильнее. 
Обычному public конструктору нужно отдать предпочтение 
в следующих обстоятельствах:
- класс является типом. Он не входит ни в какую интересную иерархию 
и не используется полиморфически для реализации интерфейса.
- клиенту нужно знать реализацию объекта - возможно, 
с точки зрения выбора "стратегии".
- все атрибуты объекта доступны клиенту, так что в конструкторе, 
предоставляемом клиенту, не создаются никакие новые объекты.
- Создание объекта не является сложным процессом
- Общедоступный конструктор должен следовать тем же правилам, что и фабрика:
это должна быть единая неделимая операция, которая подходит 
для всех инвариантов создаваемого объекта. 
Проследить, чтобы в создаваемом объекте или агрегате 
выполнялись все инварианты - эта задача возложена на фабрику.
И всё же нужно хорошенько подумать, 
прежде чем выносить свойственные объекту регламентрые правила за его пределы. 
Фабрика может делегировать проверку инвариантов самому своему продукту, 
и чаще всего лучше так и делать.

  Хранилища (Repository)
Чтобы делать с объектом что бы то ни было, нужно иметь ссылку на него. 
Как получить эту ссылку? Один из способов - создать объект, 
поскольку при создании объекта возвращается ссылка на него.
Второй способ - проследить ассоциацию. Начинаем с объекта, 
который нам уже известен, и запрашиваем у него информацию
о связанном с ним объекте.
Поиск по базе данных глобально доступен и позволяет непосредственно перейти 
к любому объекту. Нет никакой нужды в том, чтобы все объекты были
взаимосвязаны - достаточно урезать сеть взаимосвязей 
до приемлемого, управляемого состояния.
С технической точки зрения извлечение хранимого объекта это частный случай 
операции его создания, поскольку данные из базы используются 
фактически для сборки нового объекта. 
Но с концептуальной точки зрения это всего лишь 
середина цикла существования объекта-сущности.
Постоянные объекты-значения обычно находятся путем отслеживания ассоциаций 
от какой-нибудь сущности, служащей корневым объектом для инкапсулирующего их 
агрегата. Фактически доступ к объекту-значению через глобальный поиск 
часто не имеет смысла, поскольку нахождение объекта-значения по его свойствам 
эквивалентно созданию нового экземпляра с теми же свойствами. 
Впрочем, бывают и исключения...
Хранилище должно давать клиентам иллюзию, что объекты хранятся прямо в памяти.
Бывает, что объекты приходится восстанавливать (да, 
и при этом создавать новые экземпляры), но концептуально это те же самые 
объекты, которые уже существовали - это просто середина их жизненного цикла.
Можно сделать так, чтобы хранилище делегировало создание объектов фабрике.
Концепцию хранилища можно адаптировать ко многим ситуациям. Возможности ее 
реализации настолько разнообразны, что здесь будет приведено 
только несколько общих принципов, которые полезно помнить:
- Абстрагируйте тип. Хранилище как бы "содержит в себе" все экземпляры 
определенного типа, но это не значит, что для каждого класса надо иметь свое 
хранилище. В качестве типа можно использовать абстрактный падкласс из 
иерархии. Тип также может представлять собой интерфейс, 
реализаторы которого даже не связаны иерархически. 
Но это может быть и один конкретный класс. Нe забывайте, что всегда можно 
встретить препятствия на пути реализации всего этогоо из-за отсутствия 
подобного полиморфизма в технологии СУБД. 
- Извлекайте преимущества из независимости от клиента. Реализация хранилища 
предоставляет значительно больше свободы для внесения изменений,
чем тот случай, когда клиент вызывает механизмы напрямую. 
Этим можно воспользоваться для оптимизации быстродействия, 
варьируя запросы или кэшируя объекты в памяти, по желанию меняя общую 
методику хранения и поддержания целостности объектов.
Можно также облегчить тестирование клиентского кода 
и объектов модели предметной области, построив легко управляемую симуляцию
хранилища с хранением объектов в оперативной памяти.
- Оставьте контроль транзакций клиенту. Хотя именно харнилище помещает 
данные в базу и извлекает их оттуда, оно, как правило, 
не должно контролировать их завершение (т.е. выполнять фиксацию транзакции). 
Конечно, есть искушение, например, зафиксировать транзакцию после сохранения 
данных, но у клиента наверняка есть собственный
контекст для корректной инициализации и завершения отдельных рабочих операций.
Контроль транзакций со стороны клиента значительно облегчается, 
если хранилище в это дело не вмешивается.

(C) Эрик Эванс, DDD (пересказ)

'''